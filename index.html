<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Crucigramas A1</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #2980b9;
            --accent: #e74c3c;
            --bg: #ecf0f1;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 950px; width: 100%; }
        h1 { color: var(--primary); margin-top: 0; text-align: center; font-size: 24px; }
        
        .controls { display: flex; gap: 10px; justify-content: center; margin-bottom: 25px; }
        button { background: var(--secondary); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; transition: 0.2s; }
        button:hover { background: var(--primary); }
        button#new-game-btn { background: var(--accent); }

        select { padding: 10px; font-size: 16px; border: 2px solid #bdc3c7; border-radius: 8px; }

        .game-area { display: flex; flex-wrap: wrap; gap: 40px; justify-content: center; align-items: flex-start; }
        
        /* Grid Design */
        #grid-wrapper { background: #bdc3c7; padding: 5px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); overflow: auto; max-width: 100%; }
        #grid { display: grid; gap: 2px; }
        .cell { width: 40px; height: 40px; background: #ecf0f1; display: flex; justify-content: center; align-items: center; position: relative; font-weight: bold; font-size: 18px; color: var(--primary); text-transform: uppercase; }
        .cell.filled { background: white; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); animation: pop 0.3s ease-out; }
        .cell .num { position: absolute; top: 1px; left: 3px; font-size: 9px; color: var(--accent); font-weight: 700; line-height: 1; }

        /* Clues Design */
        .clues { flex: 1; min-width: 280px; max-width: 400px; background: #f9f9f9; padding: 20px; border-radius: 10px; border: 1px solid #eee; max-height: 500px; overflow-y: auto; }
        h3 { color: var(--secondary); border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; margin-top: 0; font-size: 18px; }
        ul { padding-left: 20px; margin-bottom: 20px; }
        li { margin-bottom: 8px; line-height: 1.4; color: #555; font-size: 14px; }
        li b { color: var(--primary); margin-right: 5px; }

        @keyframes pop { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        #loading { text-align: center; color: #7f8c8d; font-style: italic; }
    </style>
</head>
<body>
<div class="container">
    <h1>Generador de Crucigramas: Vocabulario</h1>
    <div id="loading">Cargando diccionario...</div>
    
    <div class="controls" style="display:none;" id="game-controls">
        <button id="generate-btn" onclick="handleGenerateClick()">游댃 Generar crucigrama</button>
    </div>

    <div class="game-area" id="game-area" style="display:none;">
        <div id="grid-wrapper"><div id="grid"></div></div>
        <div class="clues">
            <h4 id="level-title" style="margin-top:0; color:#7f8c8d;"></h4>
            <h3>Horizontales</h3><ul id="h-clues"></ul>
            <h3>Verticales</h3><ul id="v-clues"></ul>
        </div>
    </div>
</div>

<script>
let fullVocabulary = [];
let currentLevelData = null;

// 1. Cargar el JSON
async function init() {
    try {
        const response = await fetch('./vocabulario-a1-completo.json');
        if (!response.ok) throw new Error("No se pudo cargar el archivo JSON");
        fullVocabulary = await response.json();
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('game-controls').style.display = 'flex';
        document.getElementById('game-area').style.display = 'flex';
        
        generateRandomLevel();
    } catch (error) {
        document.getElementById('loading').innerHTML = "Error: Aseg칰rate de que 'vocabulario-a1-completo.json' est치 en la misma carpeta y usa un servidor local (Live Server).";
        console.error(error);
    }
}

// --- L칍GICA DEL GENERADOR ---

// Utilidad: Normalizar texto (quitar tildes para la l칩gica de la rejilla)
const normalize = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();

// Utilidad: Mezclar un arreglo (Fisher-Yates)
function shuffleArray(arr) {
    const copy = [...arr];
    for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
}

// Utilidad: Comprobar si 'word' se puede formar con las letras de 'baseWord'
// Para favorecer que aparezcan m치s palabras (estilo "letter bank" de Scrabble),
// solo verificamos que las letras existan en la palabra base, sin limitar la
// frecuencia. Tambi칠n evitamos devolver la misma palabra base.
function canBeFormedFrom(word, baseWord) {
    if (normalize(word) === normalize(baseWord)) return false;
    const letters = new Set(normalize(baseWord).split(''));
    return normalize(word).split('').every((char) => letters.has(char));
}

// Construye un listado amplio de candidatos que compartan letras con la palabra base.
// Priorizamos las palabras que se forman con la base y, si no hay suficientes,
// a침adimos otras que compartan al menos un par de letras para evitar el error de
// "menos de 3 palabras".
function buildCandidates(baseWord, validWords) {
    const baseNormalized = normalize(baseWord);
    const baseSet = new Set(baseNormalized.split(''));

    const scored = validWords
        .filter(item => normalize(item.palabra) !== baseNormalized)
        .map(item => {
            const normalized = normalize(item.palabra);
            const shared = normalized.split('').filter(ch => baseSet.has(ch)).length;
            return { item, shared, fitsBase: canBeFormedFrom(item.palabra, baseWord) };
        })
        .filter(entry => entry.shared >= 2 || entry.fitsBase);

    scored.sort((a, b) => {
        if (a.fitsBase !== b.fitsBase) return a.fitsBase ? -1 : 1; // Priorizar las que encajan totalmente
        return b.shared - a.shared; // Luego por cantidad de letras compartidas
    });

    return scored.map(entry => entry.item);
}

// Devuelve palabras m치s cortas que solo usen letras de la palabra base
function getLetterBankWords(baseWordObj, validWords) {
    const baseWord = baseWordObj.palabra;
    const baseLength = normalize(baseWord).length;
    return validWords.filter((item) => {
        const normalized = normalize(item.palabra);
        return normalized.length < baseLength && canBeFormedFrom(normalized, baseWord);
    });
}

// Genera un crucigrama asegurando que tenga al menos 3 palabras (incluida la base)
function generarCrucigrama() {
    const maxAttempts = 50;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const attemptResult = construirCrucigrama();
        if (attemptResult.palabras.length >= 2) return attemptResult;
    }
    throw new Error("No se pudo generar un crucigrama con al menos 2 palabras. Intenta de nuevo.");
}

// Funci칩n principal de generaci칩n de crucigramas infinitos (un intento)
function construirCrucigrama() {
    const validWords = fullVocabulary.filter(item => item.palabra.trim().length > 2 && !item.palabra.includes(" "));
    const longWords = validWords.filter(item => item.palabra.length >= 7);
    if (longWords.length === 0) throw new Error("No hay palabras suficientemente largas en el JSON.");

    const shuffledLongWords = shuffleArray(longWords);
    let baseObj = null;
    let letterBankWords = [];

    for (const longWord of shuffledLongWords) {
        const bankWords = getLetterBankWords(longWord, validWords);
        if (bankWords.length >= 2) {
            baseObj = longWord;
            letterBankWords = bankWords;
            break;
        }
    }

    if (!baseObj) throw new Error("No se encontraron palabras largas con al menos 2 derivadas m치s cortas.");

    const baseWord = normalize(baseObj.palabra);
    const gridSize = Math.max(30, baseWord.length * 2 + 10);
    const center = Math.floor(gridSize / 2);
    const grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
    const placedWords = [];

    // Colocar palabra madre
    const startX = center - Math.floor(baseWord.length / 2);
    const startY = center;
    placeWordOnGrid(grid, baseObj, startX, startY, 'horizontal', baseWord);
    placedWords.push({
        palabra: baseObj.palabra,
        pista: baseObj.traduccion_ingles,
        orientacion: 'horizontal',
        x: startX,
        y: startY,
        desglose: baseWord.split('')
    });

    // Filtrado de candidatos tipo Letter Bank, priorizando las palabras m치s cortas construidas con la base
    const candidates = [];
    const addCandidate = (item) => {
        const key = normalize(item.palabra);
        if (!candidates.some((cand) => normalize(cand.palabra) === key)) {
            candidates.push(item);
        }
    };

    shuffleArray(letterBankWords).forEach(addCandidate);
    buildCandidates(baseWord, validWords).forEach(addCandidate);

    for (let candObj of candidates) {
        const candStr = normalize(candObj.palabra);
        let placed = false;
        const shuffledPlaced = shuffleArray(placedWords);

        for (let target of shuffledPlaced) {
            if (placed) break;
            const targetStr = normalize(target.palabra);

            for (let i = 0; i < candStr.length; i++) {
                if (placed) break;
                for (let j = 0; j < targetStr.length; j++) {
                    if (candStr[i] !== targetStr[j]) continue;

                    const newDir = target.orientacion === 'horizontal' ? 'vertical' : 'horizontal';
                    const ix = target.x + (target.orientacion === 'horizontal' ? j : 0);
                    const iy = target.y + (target.orientacion === 'horizontal' ? 0 : j);
                    const propX = newDir === 'horizontal' ? ix - i : ix;
                    const propY = newDir === 'vertical' ? iy - i : iy;

                    if (isValidPlacement(grid, candStr, propX, propY, newDir)) {
                        placeWordOnGrid(grid, candObj, propX, propY, newDir, candStr);
                        placedWords.push({
                            palabra: candObj.palabra,
                            pista: candObj.traduccion_ingles,
                            orientacion: newDir,
                            x: propX,
                            y: propY,
                            desglose: candStr.split('')
                        });
                        placed = true;
                        break;
                    }
                }
            }
        }
    }

    let minX = Infinity, minY = Infinity;
    placedWords.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); });
    placedWords.forEach(p => { p.x -= minX; p.y -= minY; });

    const shorterWordsPlaced = placedWords.filter((p) => normalize(p.palabra).length < baseWord.length);

    if (placedWords.length >= 3 && shorterWordsPlaced.length >= 2) {
        return { palabras: placedWords, base: baseObj };
    }

    return { palabras: [], base: baseObj };
}

// Funci칩n de conveniencia para la UI actual
function generateRandomLevel() {
    try {
        const { palabras, base } = generarCrucigrama();
        document.getElementById('level-title').innerText = `Nivel basado en: ${base.palabra.toUpperCase()} (${base.traduccion_ingles})`;
        renderGame(palabras);
    } catch (error) {
        alert(error.message);
    }
}

function handleGenerateClick() {
    const btn = document.getElementById('generate-btn');
    btn.disabled = true;
    btn.innerText = 'Generando...';

    setTimeout(() => {
        generateRandomLevel();
        btn.disabled = false;
        btn.innerText = '游댃 Generar crucigrama';
    }, 50);
}

function isValidPlacement(grid, word, x, y, dir) {
    const len = word.length;
    const h = grid.length;
    const w = grid[0].length;

    // 1. Check Bounds (L칤mites)
    if (x < 1 || y < 1 || x + (dir === 'horizontal' ? len : 1) >= w - 1 || y + (dir === 'vertical' ? len : 1) >= h - 1) return false;

    for (let i = 0; i < len; i++) {
        let cx = x + (dir === 'horizontal' ? i : 0);
        let cy = y + (dir === 'vertical' ? i : 0);
        let char = word[i];

        let cellContent = grid[cy][cx];

        // Si hay letra (Intersecci칩n), debe ser la misma
        if (cellContent !== null) {
            if (cellContent.char !== char) return false;
            if (cellContent.dirs.has(dir)) return false; // No solapar en la misma direcci칩n
        }

        // REGLA DE ADYACENCIA (CORREGIDA):
        // Si la celda est치 vac칤a, verificamos que no pegue con otras palabras,
        // PERO ignoramos los vecinos en el mismo eje de la palabra actual.
        if (cellContent === null) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    // --- CORRECCI칍N AQU칈 ---
                    // Si escribimos horizontal, no verificamos vecinos izquierda/derecha dentro del bucle
                    // (ya que eso lo controlan los l칤mites start/end m치s abajo y el propio flujo de la palabra).
                    if (dir === 'horizontal' && dy === 0) continue;
                    if (dir === 'vertical' && dx === 0) continue;
                    // -----------------------

                    const nx = cx + dx;
                    const ny = cy + dy;
                    if (grid[ny] && grid[ny][nx] !== null) return false;
                }
            }
        }

        // Verificar extremos (antes de la primera letra y despu칠s de la 칰ltima)
        // Esto asegura que no pegamos la palabra "culo con culo" con otra existente.
        if (i === 0) {
            let bx = x + (dir === 'horizontal' ? -1 : 0);
            let by = y + (dir === 'vertical' ? -1 : 0);
            if (grid[by][bx] !== null) return false;
        }
        if (i === len - 1) {
            let ax = x + (dir === 'horizontal' ? len : 0);
            let ay = y + (dir === 'vertical' ? len : 0);
            if (grid[ay][ax] !== null) return false;
        }
    }
    return true;
}

function placeWordOnGrid(grid, wordObj, x, y, dir, cleanWord) {
    for (let i = 0; i < cleanWord.length; i++) {
        let cx = x + (dir === 'horizontal' ? i : 0);
        let cy = y + (dir === 'vertical' ? i : 0);
        if (!grid[cy][cx]) {
            grid[cy][cx] = { char: cleanWord[i], dirs: new Set([dir]) };
        } else {
            grid[cy][cx].dirs.add(dir);
        }
    }
}

// --- RENDERIZADO (IGUAL QUE ANTES PERO ADAPTADO) ---

function renderGame(wordsData) {
    const gridEl = document.getElementById('grid');
    const hEl = document.getElementById('h-clues');
    const vEl = document.getElementById('v-clues');
    
    // Calcular dimensiones finales
    let cols = 0, rows = 0;
    wordsData.forEach(p => {
        if (p.orientacion === 'horizontal') { cols = Math.max(cols, p.x + p.desglose.length); rows = Math.max(rows, p.y + 1); }
        else { cols = Math.max(cols, p.x + 1); rows = Math.max(rows, p.y + p.desglose.length); }
    });

    // Mapear celdas
    const map = Array.from({ length: rows }, () => Array(cols).fill(null));
    wordsData.forEach((p, wi) => {
        let cx = p.x, cy = p.y;
        p.desglose.forEach((char, ci) => {
            if (!map[cy][cx]) map[cy][cx] = { char: char, nums: [] };
            if (ci === 0) map[cy][cx].nums.push(wi + 1); // N칰mero de la pista
            p.orientacion === 'horizontal' ? cx++ : cy++;
        });
    });

    // Dibujar Grid
    gridEl.style.gridTemplateColumns = `repeat(${cols}, 40px)`;
    gridEl.innerHTML = ''; hEl.innerHTML = ''; vEl.innerHTML = '';

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let cell = document.createElement('div'); cell.className = 'cell';
            if (map[r][c]) {
                cell.classList.add('filled'); cell.innerText = map[r][c].char;
                if (map[r][c].nums.length) {
                    let n = document.createElement('span'); n.className = 'num';
                    n.innerText = map[r][c].nums.join('/'); cell.appendChild(n);
                }
            } else {
                cell.style.background = "transparent"; // Ocultar celdas vac칤as visualmente
                cell.style.boxShadow = "none";
            }
            gridEl.appendChild(cell);
        }
    }

    // Dibujar Pistas
    wordsData.forEach((p, i) => {
        let li = document.createElement('li'); 
        li.innerHTML = `<b>${i + 1}.</b> ${p.pista} <i style="color:#95a5a6; font-size:0.8em;">(${p.palabra})</i>`; // Muestro la respuesta temporalmente para debug, puedes quitarlo
        li.innerHTML = `<b>${i + 1}.</b> ${p.pista}`; // Versi칩n final limpia
        p.orientacion === 'horizontal' ? hEl.appendChild(li) : vEl.appendChild(li);
    });
}

// Iniciar aplicaci칩n
init();

</script>
</body>
</html>
