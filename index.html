<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Crucigramas A1</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #2980b9;
            --accent: #e74c3c;
            --bg: #ecf0f1;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 950px; width: 100%; }
        h1 { color: var(--primary); margin-top: 0; text-align: center; font-size: 24px; }
        
        .controls { display: flex; gap: 10px; justify-content: center; margin-bottom: 25px; }
        button { background: var(--secondary); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; transition: 0.2s; }
        button:hover { background: var(--primary); }
        button#new-game-btn { background: var(--accent); }

        select { padding: 10px; font-size: 16px; border: 2px solid #bdc3c7; border-radius: 8px; }

        .game-area { display: flex; flex-wrap: wrap; gap: 40px; justify-content: center; align-items: flex-start; }
        
        /* Grid Design */
        #grid-wrapper { background: #bdc3c7; padding: 5px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); overflow: auto; max-width: 100%; }
        #grid { display: grid; gap: 2px; }
        .cell { width: 40px; height: 40px; background: #ecf0f1; display: flex; justify-content: center; align-items: center; position: relative; font-weight: bold; font-size: 18px; color: var(--primary); text-transform: uppercase; }
        .cell.filled { background: white; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); animation: pop 0.3s ease-out; }
        .cell .num { position: absolute; top: 1px; left: 3px; font-size: 9px; color: var(--accent); font-weight: 700; line-height: 1; }

        /* Clues Design */
        .clues { flex: 1; min-width: 280px; max-width: 400px; background: #f9f9f9; padding: 20px; border-radius: 10px; border: 1px solid #eee; max-height: 500px; overflow-y: auto; }
        h3 { color: var(--secondary); border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; margin-top: 0; font-size: 18px; }
        ul { padding-left: 20px; margin-bottom: 20px; }
        li { margin-bottom: 8px; line-height: 1.4; color: #555; font-size: 14px; }
        li b { color: var(--primary); margin-right: 5px; }

        @keyframes pop { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        #loading { text-align: center; color: #7f8c8d; font-style: italic; }
    </style>
</head>
<body>
<div class="container">
    <h1>Generador de Crucigramas: Vocabulario</h1>
    <div id="loading">Cargando diccionario...</div>
    
    <div class="controls" style="display:none;" id="game-controls">
        <button id="generate-btn" onclick="handleGenerateClick()">游댃 Generar crucigrama</button>
    </div>

    <div class="game-area" id="game-area" style="display:none;">
        <div id="grid-wrapper"><div id="grid"></div></div>
        <div class="clues">
            <h4 id="level-title" style="margin-top:0; color:#7f8c8d;"></h4>
            <h3>Horizontales</h3><ul id="h-clues"></ul>
            <h3>Verticales</h3><ul id="v-clues"></ul>
        </div>
    </div>
</div>

<script>
let fullVocabulary = [];
let currentLevelData = null;

// 1. Cargar el JSON
async function init() {
    try {
        const response = await fetch('vocabulario-a1-completo.json');
        if (!response.ok) throw new Error("No se pudo cargar el archivo JSON");
        fullVocabulary = await response.json();
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('game-controls').style.display = 'flex';
        document.getElementById('game-area').style.display = 'flex';
        
        generateRandomLevel();
    } catch (error) {
        document.getElementById('loading').innerHTML = "Error: Aseg칰rate de que 'vocabulario-a1-completo.json' est치 en la misma carpeta y usa un servidor local (Live Server).";
        console.error(error);
    }
}

// --- L칍GICA DEL GENERADOR ---

// Utilidad: Normalizar texto (quitar tildes para la l칩gica de la rejilla)
const normalize = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();

// Utilidad: Mezclar un arreglo (Fisher-Yates)
function shuffleArray(arr) {
    const copy = [...arr];
    for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
}

// Utilidad: Comprobar si 'word' se puede formar con las letras de 'baseWord'
function canBeFormedFrom(word, baseWord) {
    if (word === baseWord) return false; // No queremos la misma palabra repetida
    const baseMap = {};
    for (let char of normalize(baseWord)) baseMap[char] = (baseMap[char] || 0) + 1;
    
    for (let char of normalize(word)) {
        if (!baseMap[char]) return false;
        baseMap[char]--;
        if (baseMap[char] < 0) return false;
    }
    return true;
}

// Funci칩n principal de generaci칩n de crucigramas infinitos
function generarCrucigrama() {
    const validWords = fullVocabulary.filter(item => item.palabra.trim().length > 2 && !item.palabra.includes(" "));
    const longWords = validWords.filter(item => item.palabra.length >= 7);
    if (longWords.length === 0) throw new Error("No hay palabras suficientemente largas en el JSON.");

    const baseObj = longWords[Math.floor(Math.random() * longWords.length)];
    const baseWord = normalize(baseObj.palabra);
    const gridSize = Math.max(30, baseWord.length * 2 + 10);
    const center = Math.floor(gridSize / 2);
    const grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
    const placedWords = [];

    // Colocar palabra madre
    const startX = center - Math.floor(baseWord.length / 2);
    const startY = center;
    placeWordOnGrid(grid, baseObj, startX, startY, 'horizontal', baseWord);
    placedWords.push({
        palabra: baseObj.palabra,
        pista: baseObj.traduccion_ingles,
        orientacion: 'horizontal',
        x: startX,
        y: startY,
        desglose: baseWord.split('')
    });

    // Filtrado de candidatos tipo Letter Bank
    const candidates = shuffleArray(validWords.filter(item => canBeFormedFrom(item.palabra, baseWord)));

    for (let candObj of candidates) {
        const candStr = normalize(candObj.palabra);
        let placed = false;
        const shuffledPlaced = shuffleArray(placedWords);

        for (let target of shuffledPlaced) {
            if (placed) break;
            const targetStr = normalize(target.palabra);

            for (let i = 0; i < candStr.length; i++) {
                if (placed) break;
                for (let j = 0; j < targetStr.length; j++) {
                    if (candStr[i] !== targetStr[j]) continue;

                    const newDir = target.orientacion === 'horizontal' ? 'vertical' : 'horizontal';
                    const ix = target.x + (target.orientacion === 'horizontal' ? j : 0);
                    const iy = target.y + (target.orientacion === 'horizontal' ? 0 : j);
                    const propX = newDir === 'horizontal' ? ix - i : ix;
                    const propY = newDir === 'vertical' ? iy - i : iy;

                    if (isValidPlacement(grid, candStr, propX, propY, newDir)) {
                        placeWordOnGrid(grid, candObj, propX, propY, newDir, candStr);
                        placedWords.push({
                            palabra: candObj.palabra,
                            pista: candObj.traduccion_ingles,
                            orientacion: newDir,
                            x: propX,
                            y: propY,
                            desglose: candStr.split('')
                        });
                        placed = true;
                        break;
                    }
                }
            }
        }
    }

    let minX = Infinity, minY = Infinity;
    placedWords.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); });
    placedWords.forEach(p => { p.x -= minX; p.y -= minY; });

    return { palabras: placedWords, base: baseObj };
}

// Funci칩n de conveniencia para la UI actual
function generateRandomLevel() {
    try {
        const { palabras, base } = generarCrucigrama();
        document.getElementById('level-title').innerText = `Nivel basado en: ${base.palabra.toUpperCase()} (${base.traduccion_ingles})`;
        renderGame(palabras);
    } catch (error) {
        alert(error.message);
    }
}

function handleGenerateClick() {
    const btn = document.getElementById('generate-btn');
    btn.disabled = true;
    btn.innerText = 'Generando...';

    setTimeout(() => {
        generateRandomLevel();
        btn.disabled = false;
        btn.innerText = '游댃 Generar crucigrama';
    }, 50);
}

function isValidPlacement(grid, word, x, y, dir) {
    const len = word.length;
    const h = grid.length;
    const w = grid[0].length;

    // 1. Check Bounds
    if (x < 1 || y < 1 || x + (dir === 'horizontal' ? len : 1) >= w - 1 || y + (dir === 'vertical' ? len : 1) >= h - 1) return false;

    for (let i = 0; i < len; i++) {
        let cx = x + (dir === 'horizontal' ? i : 0);
        let cy = y + (dir === 'vertical' ? i : 0);
        let char = word[i];

        // Verificar celda actual
        let cellContent = grid[cy][cx];
        
        // Si hay letra, debe ser la misma (intersecci칩n)
        if (cellContent !== null && cellContent !== char) return false;

        // REGLA DE ADYACENCIA:
        // Si la celda estaba vac칤a (no es intersecci칩n), verificamos vecinos
        if (cellContent === null) {
            // Vecinos ortogonales (Arriba, Abajo, Izq, Der) deben estar vac칤os
            // excepto si son parte de una l칤nea v치lida que estamos cruzando (eso ya se valida indirectamente)
            // La forma f치cil: No puede haber NADA adyacente que no sea parte del cruce permitido.
            
            let neighbors = [
                {nx: cx+1, ny: cy}, {nx: cx-1, ny: cy},
                {nx: cx, ny: cy+1}, {nx: cx, ny: cy-1}
            ];

            for (let n of neighbors) {
                // Si el vecino tiene letra
                if (grid[n.ny][n.nx] !== null) {
                    // Solo es v치lido si esa letra pertenece a una palabra perpendicular que cruza EXACTAMENTE en (cx, cy)
                    // Pero como estamos en el bloque "cellContent === null", significa que aqu칤 NO hay cruce previo.
                    // Por tanto, no deber칤amos tener ning칰n vecino.
                    return false;
                }
            }
        }
        
        // Verificar extremos (antes de la primera letra y despu칠s de la 칰ltima)
        if (i === 0) {
            let bx = x + (dir === 'horizontal' ? -1 : 0);
            let by = y + (dir === 'vertical' ? -1 : 0);
            if (grid[by][bx] !== null) return false;
        }
        if (i === len - 1) {
            let ax = x + (dir === 'horizontal' ? 1 : 0);
            let ay = y + (dir === 'vertical' ? 1 : 0);
            if (grid[ay][ax] !== null) return false;
        }
    }
    return true;
}

function placeWordOnGrid(grid, wordObj, x, y, dir, cleanWord) {
    for (let i = 0; i < cleanWord.length; i++) {
        let cx = x + (dir === 'horizontal' ? i : 0);
        let cy = y + (dir === 'vertical' ? i : 0);
        grid[cy][cx] = cleanWord[i];
    }
}

// --- RENDERIZADO (IGUAL QUE ANTES PERO ADAPTADO) ---

function renderGame(wordsData) {
    const gridEl = document.getElementById('grid');
    const hEl = document.getElementById('h-clues');
    const vEl = document.getElementById('v-clues');
    
    // Calcular dimensiones finales
    let cols = 0, rows = 0;
    wordsData.forEach(p => {
        if (p.orientacion === 'horizontal') { cols = Math.max(cols, p.x + p.desglose.length); rows = Math.max(rows, p.y + 1); }
        else { cols = Math.max(cols, p.x + 1); rows = Math.max(rows, p.y + p.desglose.length); }
    });

    // Mapear celdas
    const map = Array.from({ length: rows }, () => Array(cols).fill(null));
    wordsData.forEach((p, wi) => {
        let cx = p.x, cy = p.y;
        p.desglose.forEach((char, ci) => {
            if (!map[cy][cx]) map[cy][cx] = { char: char, nums: [] };
            if (ci === 0) map[cy][cx].nums.push(wi + 1); // N칰mero de la pista
            p.orientacion === 'horizontal' ? cx++ : cy++;
        });
    });

    // Dibujar Grid
    gridEl.style.gridTemplateColumns = `repeat(${cols}, 40px)`;
    gridEl.innerHTML = ''; hEl.innerHTML = ''; vEl.innerHTML = '';

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let cell = document.createElement('div'); cell.className = 'cell';
            if (map[r][c]) {
                cell.classList.add('filled'); cell.innerText = map[r][c].char;
                if (map[r][c].nums.length) {
                    let n = document.createElement('span'); n.className = 'num';
                    n.innerText = map[r][c].nums.join('/'); cell.appendChild(n);
                }
            } else {
                cell.style.background = "transparent"; // Ocultar celdas vac칤as visualmente
                cell.style.boxShadow = "none";
            }
            gridEl.appendChild(cell);
        }
    }

    // Dibujar Pistas
    wordsData.forEach((p, i) => {
        let li = document.createElement('li'); 
        li.innerHTML = `<b>${i + 1}.</b> ${p.pista} <i style="color:#95a5a6; font-size:0.8em;">(${p.palabra})</i>`; // Muestro la respuesta temporalmente para debug, puedes quitarlo
        li.innerHTML = `<b>${i + 1}.</b> ${p.pista}`; // Versi칩n final limpia
        p.orientacion === 'horizontal' ? hEl.appendChild(li) : vEl.appendChild(li);
    });
}

// Iniciar aplicaci칩n
init();

</script>
</body>
</html>
